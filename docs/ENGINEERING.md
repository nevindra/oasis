# Engineering Guidelines

Engineering principles for all contributors (human and LLM). Read this before writing any code.

Oasis is a Go framework for building autonomous AI agents — designed for production today, ready for the next leap in AI capabilities tomorrow.

## API Strategy (v1.0.0)

v1.0.0 is a one-way door. Every exported symbol that ships becomes a permanent contract. The pre-v1 period is our last chance to get the API surface right.

**Breaking-change window.** From now until v1.0.0 is tagged, breaking changes are expected and encouraged when they make the final API surface cleaner, more consistent, or more performant. Each breaking change must justify itself — write a migration note in the PR description showing what it simplifies. After v1.0.0, semver rules apply strictly: no breaking changes until v2.

**Mandated API audit.** Before tagging v1.0.0, every exported interface, type, and function must pass review: *"Does this earn its place in the v1 surface?"* If the answer is no — merge it, internalize it, or remove it. Document each decision in `docs/plans/`.

1. **Consolidate aggressively.** If two interfaces overlap or can become one without losing expressiveness, they must be merged. If a type exists only for historical reasons, remove it. Fewer, more powerful primitives beat many narrow ones.
2. **Break what needs breaking.** Rename for clarity, change signatures for consistency, restructure packages for coherence. The cost of a breaking change now is a migration note. The cost of a bad API in v1 is forever.
3. **Every export is a commitment.** New exported symbols still require a design doc in `docs/plans/`. But now the bar is higher: does this *need* to be public, or can it stay internal?
4. **DX wins without new API surface.** Better error messages, examples, copy-paste-able snippets reduce friction without adding maintenance burden. This still applies.

---

## Design Principles

Every design decision asks two questions:

1. **Does this work reliably in production today?**
2. **Will this still work when agents get 10x smarter?**

### 1. Build for Production Today, Design for Autonomy Tomorrow

AI capabilities grow in jumps. The framework must handle today's workloads reliably while being ready for the next jump without breaking what works.

**Production readiness:**

- Every component must handle graceful shutdown via context cancellation.
- Bound all resources — goroutines, channels, buffers, caches. Unbounded growth is a production incident waiting to happen.
- Distinguish transient vs permanent errors. Transient (429, 5xx, timeout) → retry with backoff. Permanent (400, 404) → return immediately.
- Degrade, don't crash. A partially functional agent is infinitely more useful than a dead one.

**Future readiness:**

- Design interfaces that accommodate autonomy. Today's agents follow explicit tool-calling loops. Tomorrow's may dynamically discover tools, spawn sub-agents, or negotiate task delegation. Interfaces should not assume a fixed execution pattern.
- Keep protocol types open for extension. Prefer structs with optional fields over rigid signatures. Adding a field is non-breaking; adding a parameter is breaking.
- Think in composability. An Agent that contains Agents. A Tool that wraps an Agent. A Network that routes to Networks. Recursive composition is how simple primitives produce emergent behavior.

### 2. Composability Over Convenience

Primitives that snap together to form systems more capable than any individual piece.

- Interfaces at natural boundaries — between your system and an external service, not between two internal functions that always change together.
- Depend on behavior, not implementation. Consumers shouldn't care whether storage is SQLite or Postgres.
- Explicit dependencies. Constructor injection, not service locator. Dependencies visible in function signatures. No hidden side effects.
- Earn every abstraction. Write concrete code first. Extract only when a pattern repeats 3x. No `utils`, `helpers`, or `common` packages. Framework primitives are different — they're designed for composability from the start.

### 3. Code for Dual Readers — Human and Agent

Code is read by humans today and will be read, extended, and generated by agents tomorrow.

- Names explain *intent*, not *implementation*. `BuildContext` over `GetTop15FactsAndFormat`.
- Comments explain **why**, not **what**. If a comment restates the code, delete it.
- Godoc on every exported symbol — explain the contract, not just "returns X".
- Interface contracts in comments — document invariants, thread-safety, nil/zero behavior.
- Consistent patterns. When every Tool follows the same Execute pattern, agents generate correct code on the first try.
- Top-to-bottom flow. Early return for edge cases, happy path below. Max 2 levels of nesting.

### 4. Fail Gracefully, Recover Autonomously

An autonomous agent can't ask a human every time something goes wrong.

- Never crash on recoverable errors. Memory extraction fails? Chat continues.
- Error messages must be actionable. `"invalid args: expected string for 'query' field"`, not `"invalid args"`.
- `ToolResult` is not an error. `Tool.Execute` always returns nil Go error. Business failures go in `ToolResult.Error`. Go errors = infrastructure failure only.

---

## Production Engineering

Oasis is designed for deployment in production systems. These rules come from real bugs fixed in the v0.8.0 hardening cycle.

### Goroutine Discipline

Every goroutine must have a clear shutdown path tied to context cancellation. A goroutine without a shutdown path is a memory leak. Always use `select` with `ctx.Done()` — never rely solely on channel closure for termination.

### Channel Safety

Use buffered channels for producer-consumer patterns with a justified buffer size. The sender owns the close — never close from the receiver side. Use `sync.Once` to prevent double-close panics.

### Memory and Resource Bounding

Bound all caches, buffers, and queues. If it can grow, it needs a cap. When a bound is hit, degrade gracefully (drop oldest, reject new) rather than blocking indefinitely or panicking. Truncate large text fields at ingestion boundaries, not deep in processing pipelines.

### Context Propagation

Every public function that does I/O or runs longer than trivially takes `context.Context` as its first parameter. Never store contexts in structs — pass them through call chains. Derive child contexts for sub-operations so cancellation propagates correctly.

### Concurrency Patterns

Heavy non-critical work (memory extraction, embedding) runs in background goroutines with bounded concurrency. LLM streaming uses buffered channels. Protect shared mutable state with `sync.Mutex` — prefer narrowing the critical section over wrapping entire methods.

### Graceful Shutdown

Components that start background work must expose a `Close()` or accept a context whose cancellation triggers cleanup. Shutdown must drain in-flight work within a timeout, not drop it silently. Test shutdown paths — a `Close()` that's never tested is a shutdown that doesn't work.

### Performance

The run loop, tool dispatch, and streaming paths are hot. Treat them accordingly.

- **Zero-allocation hot paths.** The run loop and tool dispatch must not allocate on the common path. Use sync.Pool for transient buffers. Avoid fmt.Sprintf in hot paths — use string concatenation or pre-formatted strings.
- **Benchmark before and after.** Any change to a hot path must include benchmark results in the PR. Use `go test -bench` with `-benchmem`. Regressions need justification.
- **No reflection or unnecessary serialization in the loop.** JSON marshaling, type reflection, and interface conversions in the run loop add up fast. Marshal at boundaries (provider calls, store writes), not between internal steps.
- **Streaming must not block the sender.** Buffered channels with bounded size. If the consumer is slow, drop or backpressure — never block the LLM response path.
- **Profile before optimizing.** Don't guess. Use `pprof` to find the actual bottleneck. Premature optimization of cold paths is wasted effort.

---

## Extensibility

**During the v1.0.0 window**, the rules below are relaxed — signatures, interfaces, and package structure can all change if the change passes the API audit. After v1.0.0, these rules become hard constraints.

### New interface

Define in the root `oasis` package, document contracts and nil/zero behavior, add a concrete implementation with compile-time check. Requires a design doc in `docs/plans/` before landing. Must pass the v1 audit: *"Does this need to be a separate interface, or can it fold into an existing one?"*

### Modify existing interface

**Pre-v1:** allowed. Change signatures, rename methods, merge interfaces — with a migration note in the PR.
**Post-v1:** don't modify signatures. New capability = new interface + type assertion. New struct field = zero value preserves old behavior.

### New tool

Package in `tools/`, implement `oasis.Tool`, parse args into anonymous struct, dispatch on `name` for multi-function tools.

### New provider

Package in `provider/`, raw HTTP only, add `wrapErr()` helper. Streaming via SSE with `ch <- chunk` and `defer close(ch)`.

### New processor

Implement `PreProcessor`/`PostProcessor`/`PostToolProcessor`. Return `nil` to pass through, `ErrHalt` to short-circuit. Must be concurrent-safe. Register via `WithProcessors()`.

### New store capability

Implement as a separate optional interface. Store implementations opt in via type assertion. Do not add methods to the `Store` interface — **unless the v1 audit determines that a capability is universal enough to belong in the core interface.**

---

## Things to Never Do

These rules apply always — including during the v1.0.0 breaking-change window.

- Do not add LLM SDK dependencies — raw HTTP only
- Do not add bot/HTTP router/error wrapping/logging frameworks
- Do not cache database connections
- Do not return Go `error` from `Tool.Execute` for business failures — use `ToolResult.Error`
- Do not start goroutines without a shutdown path
- Do not use unbounded channels, caches, or buffers
- Do not store `context.Context` in structs
- Do not ship v1.0.0 with any exported symbol that hasn't passed the API audit
