# Engineering Guidelines

Engineering principles for all contributors — human and LLM. Read this before writing any code.

Oasis is a Go framework for building autonomous AI agents — designed for production today, ready for the next leap in AI capabilities tomorrow.

> **Current phase: pre-v1.0.0** — breaking changes are expected and encouraged when they improve the final API surface. Each breaking change requires a migration note in the PR description. After v1.0.0, semver applies strictly.

---

## API Strategy

Every exported symbol is a permanent contract. The API surface must earn its place.

1. **Consolidate aggressively.** If two interfaces overlap or can become one without losing expressiveness, merge them. Fewer, more powerful primitives beat many narrow ones.
2. **Every export is a commitment.** New exported symbols require a design doc in `docs/plans/`. The bar: does this *need* to be public, or can it stay internal?
3. **Pre-v1: break what needs breaking.** Rename for clarity, change signatures for consistency, restructure packages for coherence. The cost of a breaking change now is a migration note. The cost of a wrong API in v1 is forever.
4. **Post-v1: extend, never break.** New capability = new interface + type assertion. New struct field = zero value preserves old behavior. Semver strictly enforced.
5. **Improve DX through clarity, not surface area.** Better error messages, examples, and copy-paste-able snippets reduce friction without adding exports to maintain.

---

## Design Principles

Every design decision asks two questions:

1. **Does this work reliably in production today?**
2. **Will this still work when agents get 10x smarter?**

### 1. Build for Production Today, Design for Autonomy Tomorrow

AI capabilities grow in jumps. The framework must handle today's workloads reliably while being ready for the next jump without breaking what works.

**Production readiness:** Code must survive real deployment — graceful shutdown, bounded resources, intelligent error recovery. A partially functional agent is infinitely more useful than a dead one. See [Production Engineering](#production-engineering) for the concrete rules.

**Future readiness:**

- Design interfaces that accommodate autonomy. Today's agents follow explicit tool-calling loops. Tomorrow's may dynamically discover tools, spawn sub-agents, or negotiate task delegation. Interfaces should not assume a fixed execution pattern.
- Keep protocol types open for extension. Prefer structs with optional fields over rigid signatures. Adding a field is non-breaking; adding a parameter is breaking.
- Think in composability. An Agent that contains Agents. A Tool that wraps an Agent. A Network that routes to Networks. Recursive composition is how simple primitives produce emergent behavior.

**Forward-compatible API design:** Leave room in every API surface for capabilities you haven't built yet. Once v1 ships, the only way forward is extension.

- Extend via composition, not modification. Need a Provider that also does embeddings? That's a separate `EmbeddingProvider` interface — don't add methods to `Provider`.
- Zero values must preserve existing behavior. A new struct field whose zero value changes behavior is a silent breaking change.
- Optional capabilities via interface assertion — check at runtime, don't force at compile time.

```go
// Optional capability via separate interface
type StreamingAgent interface {
    Agent
    ExecuteStream(ctx context.Context, task AgentTask, ch chan<- string) (AgentResult, error)
}

// Check at runtime — existing code never breaks
if sa, ok := agent.(StreamingAgent); ok {
    return sa.ExecuteStream(ctx, task, ch)
}
```

### 2. Composability Over Convenience

Primitives that snap together to form systems more capable than any individual piece.

- Interfaces at natural boundaries — between your system and an external service, not between two internal functions that always change together.
- Depend on behavior, not implementation. Consumers shouldn't care whether storage is SQLite or Postgres.
- Explicit dependencies. Constructor injection, not service locator. Dependencies visible in function signatures. No hidden side effects.
- Earn every abstraction. Write concrete code first. Extract only when a pattern repeats 3x. No `utils`, `helpers`, or `common` packages. Framework primitives are different — they're designed for composability from the start.

### 3. Code for Dual Readers — Human and Agent

Code is read by humans today and will be read, extended, and generated by agents tomorrow.

- Names explain *intent*, not *implementation*. `BuildContext` over `GetTop15FactsAndFormat`.
- Comments explain **why**, not **what**. If a comment restates the code, delete it.
- Godoc on every exported symbol — explain the contract, not just "returns X".
- Interface contracts in comments — document invariants, thread-safety, nil/zero behavior.
- Consistent patterns. When every Tool follows the same Execute pattern, agents generate correct code on the first try.
- Top-to-bottom flow. Early return for edge cases, happy path below. Max 2 levels of nesting.

### 4. Fail Gracefully, Recover Autonomously

An autonomous agent can't ask a human every time something goes wrong.

- Never crash on recoverable errors. Memory extraction fails? Chat continues.
- Error messages must be actionable. `"invalid args: expected string for 'query' field"`, not `"invalid args"`.
- `ToolResult` is not an error. `Tool.Execute` always returns nil Go error. Business failures go in `ToolResult.Error`. Go errors = infrastructure failure only.

### 5. Optimize for the First 15 Minutes

A framework that's powerful but painful to use is a framework nobody uses. DX is not a feature — it's a design constraint that shapes every decision.

- Simple things must be simple. An agent with one tool and one provider should take <20 lines of code.
- Progressive disclosure. Beginners see the simple path. Power users discover depth without it getting in the way.
- Defaults must be sensible. Zero-config should produce a working, reasonable agent. Every option should have a justifiable default.
- Own your dependencies. Can stdlib or <200 lines hand-rolled solve it? Don't add the dep. For external APIs: no SDKs — raw HTTP + JSON gives full control and fewer surprises.

---

## Production Engineering

Concrete rules for production-grade code. Design Principles tell you *how to think*. This section tells you *what to do*.

### Goroutine Discipline

Every goroutine must have a clear shutdown path tied to context cancellation. A goroutine without a shutdown path is a memory leak. Always use `select` with `ctx.Done()` — never rely solely on channel closure for termination.

### Channel Safety

Use buffered channels for producer-consumer patterns with a justified buffer size. The sender owns the close — never close from the receiver side. Use `sync.Once` to prevent double-close panics.

### Memory and Resource Bounding

Bound all caches, buffers, and queues. If it can grow, it needs a cap. When a bound is hit, degrade gracefully (drop oldest, reject new) rather than blocking indefinitely or panicking. Truncate large text fields at ingestion boundaries, not deep in processing pipelines.

### Context Propagation

Every public function that does I/O or runs longer than trivially takes `context.Context` as its first parameter. Never store contexts in structs — pass them through call chains. Derive child contexts for sub-operations so cancellation propagates correctly.

### Concurrency Patterns

Heavy non-critical work (memory extraction, embedding) runs in background goroutines with bounded concurrency. LLM streaming uses buffered channels. Protect shared mutable state with `sync.Mutex` — prefer narrowing the critical section over wrapping entire methods.

### Graceful Shutdown

Components that start background work must expose a `Close()` or accept a context whose cancellation triggers cleanup. Shutdown must drain in-flight work within a timeout, not drop it silently. Test shutdown paths — a `Close()` that's never tested is a shutdown that doesn't work.

---

## Performance

The run loop, tool dispatch, and streaming paths are hot. Treat them accordingly.

- **Zero-allocation hot paths.** The run loop and tool dispatch must not allocate on the common path. Use sync.Pool for transient buffers. Avoid fmt.Sprintf in hot paths — use string concatenation or pre-formatted strings.
- **Benchmark before and after.** Any change to a hot path must include benchmark results in the PR. Use `go test -bench` with `-benchmem`. Regressions need justification.
- **No reflection or unnecessary serialization in the loop.** JSON marshaling, type reflection, and interface conversions in the run loop add up fast. Marshal at boundaries (provider calls, store writes), not between internal steps.
- **Streaming must not block the sender.** Buffered channels with bounded size. If the consumer is slow, drop or backpressure — never block the LLM response path.
- **Profile before optimizing.** Don't guess. Use `pprof` to find the actual bottleneck. Premature optimization of cold paths is wasted effort.

---

## Things to Never Do

These rules apply always — pre-v1 and post-v1.

- Do not add LLM SDK dependencies — raw HTTP only
- Do not add bot/HTTP router/error wrapping/logging frameworks
- Do not cache database connections
- Do not return Go `error` from `Tool.Execute` for business failures — use `ToolResult.Error`
- Do not start goroutines without a shutdown path
- Do not use unbounded channels, caches, or buffers
- Do not store `context.Context` in structs
- Do not ship v1.0.0 with any exported symbol that hasn't passed the API audit
