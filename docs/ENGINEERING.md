# Engineering Guidelines

Engineering principles for all contributors (human and LLM). Read this before writing any code.

Oasis is a Go framework for building autonomous AI agents — designed for production today, ready for the next leap in AI capabilities tomorrow.

## API Strategy (v0.8+)

Oasis has its building blocks in place. The focus shifts from adding primitives to making them work together seamlessly.

1. **Integration over invention.** Polish how existing primitives compose. Fill genuine gaps. Don't add new abstractions speculatively.
2. **New interfaces require a design doc.** Any new exported interface must have a written design (in docs/plans/) reviewed before landing. New interfaces are welcome when they solve a real problem — this gate ensures intentionality, not bureaucracy.
3. **Consolidate when possible, extend when necessary.** If two interfaces overlap or can be combined without losing expressiveness, combine them. When adding new capabilities, prefer optional interfaces discovered via type assertion over growing existing ones.
4. **DX wins without new API surface.** Better error messages, examples, copy-paste-able snippets reduce friction without adding maintenance burden.

---

## Design Principles

Every design decision asks two questions:

1. **Does this work reliably in production today?**
2. **Will this still work when agents get 10× smarter?**

### 1. Build for Production Today, Design for Autonomy Tomorrow

AI capabilities grow in jumps. The framework must handle today's workloads reliably while being ready for the next jump without breaking what works.

**Production readiness:**

- Every component must handle graceful shutdown via context cancellation.
- Bound all resources — goroutines, channels, buffers, caches. Unbounded growth is a production incident waiting to happen.
- Distinguish transient vs permanent errors. Transient (429, 5xx, timeout) → retry with backoff. Permanent (400, 404) → return immediately.
- Degrade, don't crash. A partially functional agent is infinitely more useful than a dead one.

**Future readiness:**

- Design interfaces that accommodate autonomy. Today's agents follow explicit tool-calling loops. Tomorrow's may dynamically discover tools, spawn sub-agents, or negotiate task delegation. Interfaces should not assume a fixed execution pattern.
- Keep protocol types open for extension. Prefer structs with optional fields over rigid signatures. Adding a field is non-breaking; adding a parameter is breaking.
- Think in composability. An Agent that contains Agents. A Tool that wraps an Agent. A Network that routes to Networks. Recursive composition is how simple primitives produce emergent behavior.

### 2. Composability Over Convenience

Primitives that snap together to form systems more capable than any individual piece.

- Interfaces at natural boundaries — between your system and an external service, not between two internal functions that always change together.
- Depend on behavior, not implementation. Consumers shouldn't care whether storage is SQLite or Postgres.
- Explicit dependencies. Constructor injection, not service locator. Dependencies visible in function signatures. No hidden side effects.
- Earn every abstraction. Write concrete code first. Extract only when a pattern repeats 3×. No `utils`, `helpers`, or `common` packages. Framework primitives are different — they're designed for composability from the start.

### 3. Code for Dual Readers — Human and Agent

Code is read by humans today and will be read, extended, and generated by agents tomorrow.

- Names explain *intent*, not *implementation*. `BuildContext` over `GetTop15FactsAndFormat`.
- Comments explain **why**, not **what**. If a comment restates the code, delete it.
- Godoc on every exported symbol — explain the contract, not just "returns X".
- Interface contracts in comments — document invariants, thread-safety, nil/zero behavior.
- Consistent patterns. When every Tool follows the same Execute pattern, agents generate correct code on the first try.
- Top-to-bottom flow. Early return for edge cases, happy path below. Max 2 levels of nesting.

### 4. Fail Gracefully, Recover Autonomously

An autonomous agent can't ask a human every time something goes wrong.

- Never crash on recoverable errors. Memory extraction fails? Chat continues.
- Error messages must be actionable. `"invalid args: expected string for 'query' field"`, not `"invalid args"`.
- `ToolResult` is not an error. `Tool.Execute` always returns nil Go error. Business failures go in `ToolResult.Error`. Go errors = infrastructure failure only.

---

## Production Engineering

Oasis is designed for deployment in production systems. These rules come from real bugs fixed in the v0.8.0 hardening cycle.

### Goroutine Discipline

Every goroutine must have a clear shutdown path tied to context cancellation. A goroutine without a shutdown path is a memory leak. Always use `select` with `ctx.Done()` — never rely solely on channel closure for termination.

### Channel Safety

Use buffered channels for producer-consumer patterns with a justified buffer size. The sender owns the close — never close from the receiver side. Use `sync.Once` to prevent double-close panics.

### Memory and Resource Bounding

Bound all caches, buffers, and queues. If it can grow, it needs a cap. When a bound is hit, degrade gracefully (drop oldest, reject new) rather than blocking indefinitely or panicking. Truncate large text fields at ingestion boundaries, not deep in processing pipelines.

### Context Propagation

Every public function that does I/O or runs longer than trivially takes `context.Context` as its first parameter. Never store contexts in structs — pass them through call chains. Derive child contexts for sub-operations so cancellation propagates correctly.

### Concurrency Patterns

Heavy non-critical work (memory extraction, embedding) runs in background goroutines with bounded concurrency. LLM streaming uses buffered channels. Protect shared mutable state with `sync.Mutex` — prefer narrowing the critical section over wrapping entire methods.

### Graceful Shutdown

Components that start background work must expose a `Close()` or accept a context whose cancellation triggers cleanup. Shutdown must drain in-flight work within a timeout, not drop it silently. Test shutdown paths — a `Close()` that's never tested is a shutdown that doesn't work.

---

## Extensibility

### New interface

Define in the root `oasis` package, document contracts and nil/zero behavior, add a concrete implementation with compile-time check. Requires a design doc in docs/plans/ before landing.

### Extend existing interface

Don't modify signatures. New capability = new interface + type assertion. New struct field = zero value preserves old behavior.

### New tool

Package in `tools/`, implement `oasis.Tool`, parse args into anonymous struct, dispatch on `name` for multi-function tools.

### New provider

Package in `provider/`, raw HTTP only, add `wrapErr()` helper. Streaming via SSE with `ch <- chunk` and `defer close(ch)`.

### New processor

Implement `PreProcessor`/`PostProcessor`/`PostToolProcessor`. Return `nil` to pass through, `ErrHalt` to short-circuit. Must be concurrent-safe. Register via `WithProcessors()`.

### New store capability

Implement as a separate optional interface. Store implementations opt in via type assertion. Do not add methods to the `Store` interface.

---

## Things to Never Do

- Do not add LLM SDK dependencies — raw HTTP only
- Do not add bot/HTTP router/error wrapping/logging frameworks
- Do not cache database connections
- Do not return Go `error` from `Tool.Execute` for business failures — use `ToolResult.Error`
- Do not start goroutines without a shutdown path
- Do not use unbounded channels, caches, or buffers
- Do not store `context.Context` in structs
